{-
 - A program to compute page numbers in signatures for printing books. Re-implemented in Haskell as an exercise; originally
 - written in Lua.
 -
 - Requirements are the same: the program is to be used with Canon LBP6030 model printer or any other that employs the same
 - printing scheme: pages are output face-down. Use as follows: copy and paste the row of numbers labelled "Side 1", print,
 - take the output pages AS IS back to the input, copy and paste the row labelled "Side 2", print. The resulting signature
 - is already sorted. The book must have at least 4 empty pages in the end (required by technology).
 -}

module Main where

{-
 - Imports. The "intercalate" function is used to simplify list output, whereas "getArgs" is self-explanatory. It is
 - used if the there are CLI arguments supplied, otherwise the user is asked for input. The "die" function is used to report
 - errors.
 -}
import Data.List (intercalate)
import System.Environment (getArgs)
import System.Exit (die)
import System.IO (hFlush, stdout)

{-
 - Building the list of signatures. A signature is a triple of the form
 -
 - (signature number, list of pages for side 1, list of pages for side 2)
 -
 - The lists are generated by mapping the local functions "side1" and "side2" over a list. These formulas were derived
 - through a little bit of playing with numbers in Wolfram Mathematica.
 -}
signatures :: Int -> Int -> [(Int, [Int], [Int])]
signatures pageN sigSize = [(sig + 1, map (side1 sig) pages, map (side2 sig) pages) | sig <- [0 .. pageN `div` sigSize - 1]]
    where
        size' = sigSize `div` 2
        pages = [1 .. size']

        side1, side2 :: Int -> Int -> Int
        side1 sigNo pageNo = (sigSize * sigNo + size' + (-1)^pageNo * (pageNo - size' - 1) - 2) `mod` pageN
        side2 sigNo pageNo = (sigSize * sigNo + size' + (-1)^pageNo * (pageNo - 1) - 3) `mod` pageN + 1

-- Ask the user for inputs if they haven't supplied command line arguments.
askForInputs :: IO [Int]
askForInputs = do
    putStr "Please enter the number of pages in the book: "
    hFlush stdout
    pageN <- read <$> getLine
    putStr "Please enter the desired number of pages in a signature: "
    hFlush stdout
    sigSize <- read <$> getLine
    putStrLn ""
    return [pageN, sigSize]

-- Obviously, checking inputs for correctness.
checkInputs :: Int -> Int -> IO ()
checkInputs pageN sigSize
    | sigSize `notElem` [12, 16, 20] = die "Error: Incorrect input data: signature size must be either 12, 16 or 20"
    | pageN `mod` sigSize /= 0       = die "Error: Incorrect input data: number of pages isn't divisible by signature size"
    | otherwise                      = return ()

-- Output. Self-explanatory.
printSignatures :: [(Int, [Int], [Int])] -> IO ()
printSignatures []                   = return ()
printSignatures ((n, s1, s2) : sigs) = do
    putStrLn $ "Signature " ++ show n
    putStrLn $ "Side 1: " ++ intercalate ", " (map show s1)
    putStrLn $ "Side 2: " ++ intercalate ", " (map show s2)
    putStrLn ""
    printSignatures sigs

-- Main function.
main :: IO ()
main = do
    args <- getArgs
    pageN : sigSize : _ <- if length args >= 2
        then return $ map read args
        else askForInputs
    checkInputs pageN sigSize
    printSignatures $ signatures pageN sigSize
