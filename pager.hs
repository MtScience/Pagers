{-
 - A program to compute page numbers in signatures for printing books. Re-implemented in Haskell as an exercise; originally
 - written in Lua.
 -
 - Requirements are the same: the program is to be used with Canon LBP6030 model printer or any other that employs the same
 - printing scheme: pages are output face-down. Use as follows: copy and paste the row of numbers labelled "Side 1", print,
 - take the output pages AS IS back to the input, copy and paste the row labelled "Side 2", print. The resulting signature
 - is already sorted. The book must have at least 4 empty pages in the end (required by technology).
 -}

module Main where

{-
 - Imports. The "intercalate" function is used to simplify list output, whereas "getArgs" is self-explanatory. It was
 - possible to not use it and ask the user for the number of pages and signature size after the program is started, but
 - I wanted to implement the same functionality as the Lua version, which requires two arguments.
 -}
import Data.List (intercalate)
import System.Environment (getArgs)

{-
 - Building the list of signatures. A signature is a triple of the form
 -
 - (signature number, list of pages for side 1, list of pages for side 2)
 -
 - The lists are generated by mapping the local functions "side1" and "side2" over a list. These formulas were derived
 - through a little bit of playing with numbers in Wolfram Mathematica.
 -}
signatures :: Int -> Int -> [(Int, [Int], [Int])]
signatures pageN sigSize = [(sig + 1, map (side1 sig) pages, map (side2 sig) pages) | sig <- [0 .. pageN `div` sigSize - 1]] where
    size' = sigSize `div` 2
    pages = [1 .. size']

    side1, side2 :: Int -> Int -> Int
    side1 sigNo pageNo = (sigSize * sigNo + size' + (-1)^pageNo * (pageNo - size' - 1) - 2) `mod` pageN
    side2 sigNo pageNo = (sigSize * sigNo + size' + (-1)^pageNo * (pageNo - 1) - 3) `mod` pageN + 1

{-
 - Output. Self-explanatory.
 -}
printSignatures :: [(Int, [Int], [Int])] -> IO ()
printSignatures [(n, s1, s2)] = do
    putStrLn $ "Signature " ++ show n
    putStrLn $ "Side 1: " ++ (intercalate ", " $ map show s1)
    putStrLn $ "Side 2: " ++ (intercalate ", " $ map show s2)
printSignatures ((n, s1, s2):sigs) = do
    putStrLn $ "Signature " ++ show n
    putStrLn $ "Side 1: " ++ (intercalate ", " $ map show s1)
    putStrLn $ "Side 2: " ++ (intercalate ", " $ map show s2)
    putStrLn ""
    printSignatures sigs

{-
 - Main function. It also checks the arguments for correctness. It could be done through, e. g. Either type, but
 - this program is not complicated enough to use such powerful constructs. So it simply checks if the signature size
 - is correct and if the number of pages is divisible by it. If both conditions hold, it calls "printSignatures". Otherwise,
 - it prints the relevant message and exits.
 -}
main :: IO ()
main = do
    pageN : sigSize : _ <- map (read :: String -> Int) <$> getArgs
    if sigSize `notElem` [12, 16, 20] then
        putStrLn "Error: Incorrect input data: signature size must be either 12, 16 or 20"
    else if pageN `mod` sigSize /= 0 then
        putStrLn "Error: Incorrect input data: number of pages isn't divisible by signature size"
    else printSignatures $ signatures pageN sigSize
